#Compiling

The Clu compiler is incremental. It consists of macros and templates. Here's how it works. 

`eval` is a template form. A template form takes a string as input, using a parser. We will presume the parser is Clu, since we're discussing the Clu compiler, which is, entirely, the template form `eval`. 

The first thing the Clu parser will do is read the string into an ast, which we call a Node. Macros are hygenically expanded over this Node, then a series of transforms, defined in the body of `(deftemplate eval Clu [source] (...))`, which turn the Clu code into an AST that flattens into valid LuaJIT source code.

If the template is called from a non-template context, it then flattens and evaluates the resulting string. Note that if we were doing `(deftemplate C C-parser [source] (...)` we would want to call something like an assembler on the resulting string. In either case, if a template is called from within another template of the same context, it defers evaluation, returning the completed Node. The transformation happens in-place, that is, it is a mutation of the AST. 

"Of the same context" means a common evaluator. `deftemplate` does not require an explicit evaluator, it presumes you're building for the runtime environment. If this is overrided in the arguments, evaluation takes place when the evaluator exits. 

Therefore the transforms specified in the body of `eval` are themselves templates, with definitions like `deftemplate Clu-fn Clu.fn [source] (...))`, that are called by the macro-expanded code over Nodes with the id `fn`. These completed, we may call an optional validator on our generated tree. Validators are constructed from the same grammar as parsers, and confirm that a Node **could have** been generated by parsing over a string that is in the universe of the grammar. 

So our special forms are simply fexprs, aren't special at all, and are simply units of compilation. A syntax generates a parser automatically, that parser is combined with functions over a Node, evaluation is deferred, and when all source is loaded, the transformed code is evaluated, and the Node released for GC. 

The transform context has an important consequence, inner evaluators can be used to launch arbitrarily elaborate subprograms, either waiting for their results or simply continuing. As a salient example, the source might contain a script to launch unit tests and/or continuous integration, then continue compiling and running without waiting for the results. One might keep git parameters in a configuration table and autocommit with each run. 

There is a separate instance of the Lua evaluator called `Now`, and a template designed to use it will evaluate in the `Now` context. Note that, called within an existing `Now` context, the template wil defer, don't be thrown by the name. The effect is the same, a Now template will execute during compilation. By default, the string is parsed by Clu, it is of course possible to e.g. parse with JSON and evaluate with Now. 