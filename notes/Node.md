#<Node>

The Node metatable ends up being a central Loon idiom. Let's design it carefully.

## Structure 

Nodes are a recursive structure. We disallow back references, assuring that Nodes in any combination will walk using a naive recursive strategy.

We need back references anyway, so they're closed into functions.

Nodes are always well-formed trees. Somewhere in their structure they will have a root, which has certain special fields. Roots have the same metatable structure as any other Node. 

Most Nodes will have a subsidiary metatable generated by the grammar engine that produced the Nodes in question. Nodes are conservative, in that YAGNI way: we don't assume you'll be doing transforms, for example, so the Node type itself is not equipped with automatic index and span balancing, for example. 

So each engine attaches a metatable that itself falls back to Node, so we can change behavior on a per-engine basis.  

## root fields

### index

the index field is found in any Node that is a root. It returns the nodes in depth-first LR order, if indexed with a number. Indexed with a table, it returns the index number of the table if the table is a node within the AST, providing a simple membership test. The secondary return value in both cases is the depth of nesting. 

A Node which has an index may be stepped through without recursion, allowing LuaJIT to optimize the resulting code path easily. That and O(1) membership are worth the extra O(n) of walking the tree once, along with back references. 


## common fields

### id
 
Contains the name of the rule matched. 

### first and last

Node.first is the cursor into the string where the match begins, last is the cursor where it ends. 

### span

span is the amount of string underneath the node. This is in terms of captures, not regions. 

Not all 

##Metamethods

### root

Returns the root node of the Node. 

### range

` ast.range(<Node>) =>  <Node index> <num first>, <num last> `

Not all Nodes have an index, which woudl be a waste.

Calling node.range() will return the index itself, and the range over the index which contains the node. 

It does this by calling root(), calling itself on the index, and returning the range along with the index. 

### span

There is also a span metamethod. If a span field is not present, the value `Node.last - Node.first` is returned. Otherwise it returns `Node.span`. Note that this means that, for any Node, `Node["span"]` is either a number or a function returning a number. 

###__call

Calling an AST node compiles it and executes it, with the evaluator specified by the reference node. An AST is normally generated with a particular kind of evaluation in mind, so we attach that intention to the reference node. 

This compilation happens once, and the result is memoized. `__newindex` on any node is responsible for clearing the function cache on all upstream nodes. 

###__newindex

as mentioned, `__newindex` is responsible for checking for cached functions in upstream nodes. It is also responsible for making sure that the reference index is updated, back references are maintained, region information in the tree is correct, and so on. 

Hopefully we can have a cheap __newindex for generating ASTs from the flats, and an expensive one for modifying existing ASTs.

If we add Cor and Cow, which may not prove necessary, __newindex will have to handle those types. 

### __add

adding places the second value at the end of the index for the first Node.

Should it check to make sure the value it's placing is a useful one? Maybe.

### __sub

subtract removes the second node from the first node, if it happens to be a child member. The index is recalculated. 

### __div

dividing a Node or Forest by a string returns a Forest of all Nodes with node.id matching that string. So ` node / "rule1" / "rule2" ` would return a Forest of all Nodes in the Forest matching "rule1" that also match "rule2.

### __lt

To say `node_foo > node_bar` is to assert that node_foo has node_bar as a subnode. This is O(1) on an indexed node. 

### __le

To say `node_foo >= node_bar` is to assert either raw equality or submembership. 

### __tostring

Rewrite to use the index. 


### copy

Copying: Make a new table, copy anything that isn't an index or a backref, add all children in the same fashion, then walk the new bare AST to decorate it with an index and proper back references. Include a 'back' 
