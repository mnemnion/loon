#<Node>

The Node metatable ends up being a central Loon idiom. Let's design it carefully.

## Structure 

Nodes are a recursive structure. We disallow back references, assuring that Nodes in any combination will walk using a naive recursive strategy.

We need back references anyway, so they're closed into functions.

Nodes are always well-formed trees. Somewhere in their structure they will have a root, which has certain special fields. Roots have the same metatable structure as any other Node. 

Most Nodes will have a subsidiary metatable generated by the grammar engine that produced the Nodes in question. Nodes are conservative, in that YAGNI way: we don't assume you'll be doing transforms, for example, so the Node type itself is not equipped with automatic index and span balancing, for example. 

So each engine attaches a metatable that itself falls back to Node, so we can change behavior on a per-engine basis.  

##Metamethods

###__call

Calling an AST node compiles it and executes it, with the evaluator specified by the reference node. An AST is normally generated with a particular kind of evaluation in mind, so we attach that intention to the reference node. 

This compilation happens once, and the result is memoized. `__newindex` on any node is responsible for clearing the function cache on all upstream nodes. 

###__newindex

as mentioned, `__newindex` is responsible for checking for cached functions in upstream nodes. It is also responsible for making sure that the reference index is updated, back references are maintained, region information in the tree is correct, and so on. 

Hopefully we can have a cheap __newindex for generating ASTs from the flats, and an expensive one for modifying existing ASTs.

If we add Cor and Cow, which may not prove necessary, __newindex will have to handle those types. 

### __add

adding places the second value at the end of the index for the first Node.

Should it check to make sure the value it's placing is a useful one? Maybe.

### __sub

subtract removes the second node from the first node, if it happens to be a child member. The index is recalculated. 

### __div

dividing a Node or Forest by a string returns a Forest of all Nodes with node.id matching that string. So ` node / "rule1" / "rule2" ` would return a Forest of all Nodes in the Forest matching "rule1" that also match "rule2.

### __tostring

Rewrite to use the index. 


### copy

Copying: Make a new table, copy anything that isn't an index or a backref, add all children in the same fashion, then walk the new bare AST to decorate it with an index and proper back references. Include a 'back' 
